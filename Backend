import psycopg2
from datetime import date
from decimal import Decimal

class FinanceDB:
    def __init__(self, dbname, user, password, host="localhost", port="5432"):
        """Initializes the database connection."""
        self.conn = psycopg2.connect(
            dbname="Fin_tracker",
            user="postgres",
            password="root",
            host="localhost",
            port="5432"
        )
        self.cursor = self.conn.cursor()
        self._create_table_if_not_exists()

    def _create_table_if_not_exists(self):
        """Creates the transactions table if it doesn't exist."""
        try:
            self.cursor.execute("""
                CREATE TABLE IF NOT EXISTS transactions (
                    transaction_id VARCHAR(255) PRIMARY KEY,
                    transaction_date DATE NOT NULL,
                    description TEXT,
                    amount DECIMAL(10, 2) NOT NULL,
                    type VARCHAR(20) CHECK (type IN ('Revenue', 'Expense'))
                );
            """)
            self.conn.commit()
        except psycopg2.Error as e:
            print(f"Error creating table: {e}")
            self.conn.rollback()

    def add_transaction(self, transaction_id, transaction_date, description, amount, type):
        """CREATE operation: Adds a new transaction."""
        try:
            self.cursor.execute(
                "INSERT INTO transactions (transaction_id, transaction_date, description, amount, type) VALUES (%s, %s, %s, %s, %s)",
                (transaction_id, transaction_date, description, amount, type)
            )
            self.conn.commit()
            return True
        except psycopg2.Error as e:
            print(f"Error adding transaction: {e}")
            self.conn.rollback()
            return False

    def get_transactions(self, transaction_type=None, sort_by='transaction_date', sort_order='DESC'):
        """READ operation: Retrieves transactions with optional filtering and sorting."""
        try:
            query = "SELECT transaction_id, transaction_date, description, amount, type FROM transactions"
            params = []
            if transaction_type:
                query += " WHERE type = %s"
                params.append(transaction_type)
            
            # Ensure sort_by and sort_order are valid to prevent SQL injection
            valid_sort_by = ['transaction_date', 'amount']
            valid_sort_order = ['ASC', 'DESC']
            
            if sort_by in valid_sort_by and sort_order in valid_sort_order:
                query += f" ORDER BY {sort_by} {sort_order}"
            
            self.cursor.execute(query, params)
            return self.cursor.fetchall()
        except psycopg2.Error as e:
            print(f"Error fetching transactions: {e}")
            return []

    def update_transaction(self, transaction_id, transaction_date=None, description=None, amount=None, type=None):
        """UPDATE operation: Modifies an existing transaction."""
        try:
            updates = []
            params = []
            if transaction_date:
                updates.append("transaction_date = %s")
                params.append(transaction_date)
            if description:
                updates.append("description = %s")
                params.append(description)
            if amount:
                updates.append("amount = %s")
                params.append(amount)
            if type:
                updates.append("type = %s")
                params.append(type)

            if not updates:
                return False

            query = "UPDATE transactions SET " + ", ".join(updates) + " WHERE transaction_id = %s"
            params.append(transaction_id)
            self.cursor.execute(query, params)
            self.conn.commit()
            return True
        except psycopg2.Error as e:
            print(f"Error updating transaction: {e}")
            self.conn.rollback()
            return False

    def delete_transaction(self, transaction_id):
        """DELETE operation: Removes a transaction."""
        try:
            self.cursor.execute("DELETE FROM transactions WHERE transaction_id = %s", (transaction_id,))
            self.conn.commit()
            return True
        except psycopg2.Error as e:
            print(f"Error deleting transaction: {e}")
            self.conn.rollback()
            return False

    def get_aggregations(self):
        """Calculates and returns various business insights."""
        try:
            self.cursor.execute("SELECT COUNT(*) FROM transactions")
            total_transactions = self.cursor.fetchone()[0]

            self.cursor.execute("SELECT SUM(amount) FROM transactions WHERE type = 'Revenue'")
            total_revenue = self.cursor.fetchone()[0] or Decimal(0)

            self.cursor.execute("SELECT SUM(amount) FROM transactions WHERE type = 'Expense'")
            total_expense = self.cursor.fetchone()[0] or Decimal(0)

            net_income = total_revenue - total_expense

            return {
                'total_transactions': total_transactions,
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_income': net_income
            }
        except psycopg2.Error as e:
            print(f"Error fetching aggregations: {e}")
            return None

    def close(self):
        """Closes the database connection."""
        self.cursor.close()
        self.conn.close()

if __name__ == '__main__':
    # This block can be used for testing the FinanceDB class
    db = FinanceDB(dbname="your_db_name", user="your_user", password="your_password")
    
    # Example Usage
    # Add some transactions
    db.add_transaction("T001", date.today(), "Initial investment", Decimal(10000), "Revenue")
    db.add_transaction("T002", date.today(), "Office supplies", Decimal(150.50), "Expense")

    # Read all transactions
    transactions = db.get_transactions()
    print("All Transactions:", transactions)

    # Get business insights
    insights = db.get_aggregations()
    print("Business Insights:", insights)

    db.close()
